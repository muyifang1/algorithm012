感谢老师在毕业多年后让我回忆起了大学时候的算法课。收获比那时丰富许多。
重新清晰的理解底层数据结构，并且开始刷题的兴趣。
再以后的工作中会坚持对代码硬功底的训练！
祝顺利！

以下内容需经常回顾（持续补充中。。。）

五毒神掌 五遍刷题法 (每道题至少做5遍以上)：
第一遍不要死磕，要看代码学习（一定要看国际版的高票回答）；
有思路：自己开始写代码；不然马上看题解，默写背诵熟练；
24h后第二遍开始自己写（闭卷）；
第三遍隔天或者一周后再做一遍（时间紧的话，就只需要看脑图）；
第四/五遍隔一周或者面试前再复盘一下


解题四件套： 先了解清楚题意；尽可能多的想不同题解；分析最优的解题；再写再测试
自顶向下编程方式
最大误区：做题只做一遍
优化思想：空间换时间、升维


数据结构
一维
基础：数组 array，链表 linked list
高级：栈 stack， 队列 queue，双端队列 deque，集合 set，映射 map (hash) TreeMap、HashMap
二维
基础：树 tree，图 graph
高级：二叉搜索树 binary search tree(red-black tree,AVL)，堆 heap，并查集 disjoint set，字典树 trie
特殊
位运算 Bitwise，布隆过滤器 BloomFilter
LRU Cache


复杂度分析
数据结构	Access	Search	Insertion	Deletion
Array	O(1)	O(n)	O(n)	O(n)
Stack	O(n)	O(n)	O(1)	O(1)
Queue	O(n)	O(n)	O(1)	O(1)
Singly-Linked List	O(n)	O(n)	O(1)	O(1)
Doubly-Linked List	O(n)	O(n)	O(1)	O(1)
Skip List	O(logN)	O(logN)	O(logN)	O(logN)
Hash Table	N/A	O(1)	O(1)	O(1)
Binary Search Tree	O(logN)	O(logN)	O(logN)	O(logN)
Cartesian Tree	N/A	O(logN)	O(logN)	O(logN)
B-Tree	O(logN)	O(logN)	O(logN)	O(logN)
Read-Black Tree	O(logN)	O(logN)	O(logN)	O(logN)
Splay Tree	N/A	O(logN)	O(logN)	O(logN)
AVL Tree	O(logN)	O(logN)	O(logN)	O(logN)
KD Tree	O(logN)	O(logN)	O(logN)	O(logN)

#排序算法复杂度
排序方法	时间复杂度(平均)	时间复杂度(最坏)	时间复杂度(最好)	空间复杂度	稳定性
插入排序	O(n^2)	O(n^2)	O(n)	O(1)	稳定
希尔排序	O(n^1.3)	O(n^2)	O(n)	O(1)	不稳定
选择排序	O(n^2)	O(n^2)	O(n^2)	O(1)	不稳定
堆排序	O(nlog2^n)	O(nlog2^n)	O(nlog2^n)	O(1)	不稳定
冒泡排序	O(n^2)	O(n^2)	O(n)	O(1)	稳定
快速排序	O(nlog2^n)	O(n^2)	O(nlog2^n)	O(nlog2^n)	不稳定
归并排序	O(nlog2^n)	O(nlog2^n)	O(nlog2^n)	O(n)	稳定
计数排序	O(n+k)	O(n+k)	O(n+k)	O(n+k)	稳定
桶排序	O(n+k)	O(n^2)	O(n)	O(n+k)	稳定
基数排序	O(n*k)	O(n*k)	O(n*k)	O(n+k)	稳定
化繁为简的思想
人肉递归低效、很累-> 画出递归的状态树
找到最近最简方法，将其拆解成可重复解决的问题
数学归纳思维


<h3><a id="user-content-复杂度分析" class="anchor" aria-hidden="true" href="#复杂度分析"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>复杂度分析</h3>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>Access</th>
<th>Search</th>
<th>Insertion</th>
<th>Deletion</th>
</tr>
</thead>
<tbody>
<tr>
<td>Array</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Stack</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Queue</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Singly-Linked List</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Doubly-Linked List</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Skip List</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
</tr>
<tr>
<td>Hash Table</td>
<td>N/A</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Binary Search Tree</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
</tr>
<tr>
<td>Cartesian Tree</td>
<td>N/A</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
</tr>
<tr>
<td>B-Tree</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
</tr>
<tr>
<td>Read-Black Tree</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
</tr>
<tr>
<td>Splay Tree</td>
<td>N/A</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
</tr>
<tr>
<td>AVL Tree</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
</tr>
<tr>
<td>KD Tree</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
</tr>
</tbody>
</table>
<h3><a id="user-content-排序算法复杂度" class="anchor" aria-hidden="true" href="#排序算法复杂度"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>排序算法复杂度</h3>
<table>
<thead>
<tr>
<th>排序方法</th>
<th>时间复杂度(平均)</th>
<th>时间复杂度(最坏)</th>
<th>时间复杂度(最好)</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n^1.3)</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog2^n)</td>
<td>O(nlog2^n)</td>
<td>O(nlog2^n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog2^n)</td>
<td>O(n^2)</td>
<td>O(nlog2^n)</td>
<td>O(nlog2^n)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog2^n)</td>
<td>O(nlog2^n)</td>
<td>O(nlog2^n)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n+k)</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(n+k)</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(n*k)</td>
<td>O(n*k)</td>
<td>O(n*k)</td>
<td>O(n+k)</td>
<td>稳定</td>
</tr>
</tbody>
</table>